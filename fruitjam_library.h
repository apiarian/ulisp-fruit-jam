// fruitjam_library.h — Lisp Library content for Fruit Jam
// Loaded at boot when lisplibrary is defined.
// Uses C++ raw string literal as recommended by ulisp.com.
//
// NOTE: uLisp's reader does NOT treat ; as a line comment in the usual
// sense. It skips from ; to the next '(' character, which means any
// text containing parentheses after a ; will confuse the reader.
// Keep only pure Lisp forms inside the raw string — use C++ comments
// (outside the string) for documentation.

R"lisplibrary(

(defvar *key-up* 128)
(defvar *key-down* 129)
(defvar *key-left* 130)
(defvar *key-right* 131)
(defvar *key-home* 132)
(defvar *key-end* 133)
(defvar *key-pgup* 134)
(defvar *key-pgdn* 135)
(defvar *key-insert* 136)
(defvar *key-f1* 137)
(defvar *key-f2* 138)
(defvar *key-f3* 139)
(defvar *key-f4* 140)
(defvar *key-f5* 141)
(defvar *key-f6* 142)
(defvar *key-f7* 143)
(defvar *key-f8* 144)
(defvar *key-f9* 145)
(defvar *key-f10* 146)
(defvar *key-f11* 147)
(defvar *key-f12* 148)

(defvar *mod-ctrl* 17)
(defvar *mod-shift* 34)
(defvar *mod-alt* 68)
(defvar *mod-super* 136)

(defun key-code (k) (logand k 255))
(defun key-mod (k) (logand (ash k -8) 255))

(defvar *pkgs* nil)

(defun package-load (f)
  "Load and eval a Lisp file from SD, tracking new symbols as a package. Returns the list of new symbols."
  (package-unload f)
  (let ((before (globals)))
    (with-sd-card (s f)
      (loop (let ((form (read s)))
        (unless form (return))
        (eval form))))
    (let ((new (mapcan (lambda (s) (unless (member s before) (list s))) (globals))))
      (setf *pkgs* (cons (cons f new) *pkgs*))
      new)))

(defun package-save (f)
  "Save a loaded package's symbols back to file on SD as defun/defvar forms."
  (let ((pkg (assoc f *pkgs* :test #'string=)))
    (unless pkg (error "package not found: ~a" f))
    (with-sd-card (s f 2)
      (dolist (sym (cdr pkg))
        (let ((val (eval sym)))
          (if (and (consp val) (eq (car val) 'lambda))
            (pprint (cons 'defun (cons sym (cdr val))) s)
            (pprint (list 'defvar sym (list 'quote val)) s)))))))

(defun package-unload (f)
  "Unbind all symbols tracked by package f and remove it from *pkgs*."
  (let ((pkg (assoc f *pkgs* :test #'string=)))
    (when pkg
      (dolist (sym (cdr pkg)) (makunbound sym))
      (setf *pkgs* (mapcan (lambda (p) (unless (string= (car p) f) (list p))) *pkgs*)))))

(defun package-add (f sym)
  "Add symbol sym to package f's tracking list, creating the package if it doesn't exist. Returns sym."
  (let ((pkg (assoc f *pkgs* :test #'string=)))
    (unless pkg
      (setf *pkgs* (cons (cons f nil) *pkgs*))
      (setf pkg (car *pkgs*)))
    (unless (member sym (cdr pkg))
      (setf (cdr pkg) (cons sym (cdr pkg))))
    sym))

(defun package-remove (f sym &optional unbind)
  "Remove sym from package f's tracking list. If unbind is true, also makunbound sym. Returns sym."
  (let ((pkg (assoc f *pkgs* :test #'string=)))
    (unless pkg (error "package not found: ~a" f))
    (setf (cdr pkg) (mapcan (lambda (s) (unless (eq s sym) (list s))) (cdr pkg)))
    (when unbind (makunbound sym))
    sym))

(defun package-symbols (f)
  "Return the list of symbols tracked by package f."
  (let ((pkg (assoc f *pkgs* :test #'string=)))
    (unless pkg (error "package not found: ~a" f))
    (cdr pkg)))

(defun package-list ()
  "Return a list of all loaded package names (filenames)."
  (mapcar #'car *pkgs*))

(defun demo-leds (r g b)
  (dotimes (i 5)
    (pixels-set-pixel-color i r g b))
  (pixels-show))

(defun demo-init-brushes ()
  (dotimes (y 16)
    (dotimes (x 16)
      (when (<= (+ (* (- x 7) (- x 7)) (* (- y 7) (- y 7))) 42)
        (sprite-pixel x y 255))))
  (dotimes (y 12)
    (dotimes (x 12)
      (sprite-pixel (+ 16 x 2) (+ y 2) 255)))
  (dotimes (y 16)
    (dotimes (x 16)
      (when (<= (+ (abs (- x 7)) (abs (- y 7))) 7)
        (sprite-pixel (+ 32 x) y 255))))
  (dotimes (y 16)
    (dotimes (x 16)
      (let ((dx (abs (- x 7))) (dy (abs (- y 7))))
        (when (or (<= (+ (* dx dx) (* dy dy)) 9)
                  (and (< dx 2) (< dy 8))
                  (and (< dy 2) (< dx 8)))
          (sprite-pixel (+ 48 x) y 255)))))
  (dolist (p '((2 1) (9 0) (14 2) (5 3) (11 4) (1 5) (7 5)
               (13 6) (3 7) (10 7) (0 9) (6 8) (14 9) (4 10)
               (9 10) (12 11) (2 12) (7 12) (11 13) (5 14)
               (14 14) (1 15) (8 15)))
    (sprite-pixel (+ 64 (car p)) (cadr p) 255)))

(defun demo-ui (ci colors sz col bi)
  (let ((n (length colors)) (bw 16) (bh 12) (by 369))
    (let ((x 4))
      (dotimes (i n)
        (let ((c (nth i colors)))
          (fill-rect x by bw bh (car c))
          (when (= (car c) 0)
            (draw-rect x by bw bh 182))
          (if (= i ci)
            (draw-rect (- x 1) (- by 1) (+ bw 2) (+ bh 2) 255)
            (draw-rect (- x 1) (- by 1) (+ bw 2) (+ bh 2) 0))
          (setq x (+ x bw 3)))))
    (fill-rect 461 333 50 50 0)
    (sprite-remap 0 255 (if (= col 0) 182 col))
    (sprite-draw (* bi 16) 0 16 16
      (- 486 (* 8 sz)) (- 358 (* 8 sz)) 0 :none :none sz 0)
    (draw-rect 460 332 52 52 73)))

(defun demo-click (note)
  (audio-note 0 note 150))

(defun demo-blip ()
  (audio-note 1 84 100))

(defun demo ()
  (pixels-begin)
  (graphics-mode)
  (fill-screen 0)
  (demo-init-brushes)
  (sprite-remap 0 255 255)
  (let* ((colors '((255 255 255 255) (0 0 0 0) (224 255 0 0) (28 0 255 0)
                    (3 0 0 255) (252 255 255 0) (31 0 255 255)
                    (227 255 0 255) (240 255 128 0)
                    (182 170 170 170) (73 85 85 85)))
         (ci 0)
         (sz 1)
         (sizes '(1 2 3))
         (si 0)
         (bi 0)
         (col (car (nth ci colors)))
         (b2 nil) (b3 nil)
         (was-drawing nil))
    (set-cursor 184 4)
    (set-text-color 255 0)
    (set-text-size 2)
    (with-gfx (s) (princ "Fruit Jam" s))
    (set-text-size 1)
    (set-cursor 8 24)
    (set-text-color 182 0)
    (with-gfx (s) (princ "draw:mouse b:brush c/B2:color s/B3:size x:clear Esc:quit" s))
    (draw-line 0 38 511 38 73)
    (draw-line 0 364 511 364 73)
    (demo-ui ci colors sz col bi)
    (let ((cc (nth ci colors)))
      (demo-leds (nth 1 cc) (nth 2 cc) (nth 3 cc)))
    (mouse-show)
    (keyboard-flush)
    (audio-wave 0 :square) (audio-vol 0 15)
    (audio-wave 1 :sine) (audio-vol 1 10)
    (audio-wave 2 :sine) (audio-vol 2 100)
    (audio-envelope 2 10 150 80 300)
    (dolist (n '(60 64 67 72))
      (audio-note 2 n) (delay 200))
    (audio-release 2) (delay 400)
    (audio-stop 2) (audio-envelope 2 nil)
    (loop
      (let ((pressed (button 2)))
        (when (and pressed (not b2))
          (setq ci (mod (+ ci 1) (length colors)))
          (setq col (car (nth ci colors)))
          (demo-ui ci colors sz col bi)
          (let ((cc (nth ci colors)))
            (demo-leds (nth 1 cc) (nth 2 cc) (nth 3 cc)))
          (demo-click (+ 60 (* ci 2))))
        (setq b2 pressed))
      (let ((pressed (button 3)))
        (when (and pressed (not b3))
          (setq si (mod (+ si 1) (length sizes)))
          (setq sz (nth si sizes))
          (demo-ui ci colors sz col bi)
          (demo-click (+ 72 (* si 3))))
        (setq b3 pressed))
      (if (> (mouse-buttons) 0)
        (progn
          (let ((mx (mouse-x)) (my (mouse-y)))
            (when (and (> my 38) (< my 364))
              (sprite-remap 0 255 col)
              (sprite-draw (* bi 16) 0 16 16 (- mx 7) (- my 7) 0 :none :none sz 0)
              (unless was-drawing (demo-blip))))
          (setq was-drawing t))
        (setq was-drawing nil))
      (let ((k (keyboard)))
        (when k
          (let ((kc (key-code k)))
            (cond
              ((= kc 27)
                (mouse-hide)
                (audio-stop-all)
                (pixels-clear) (pixels-show)
                (text-mode)
                (return))
              ((or (= kc 98) (= kc 66))
                (setq bi (mod (+ bi 1) 5))
                (demo-ui ci colors sz col bi)
                (demo-click (+ 48 (* bi 4))))
              ((or (= kc 99) (= kc 67))
                (setq ci (mod (+ ci 1) (length colors)))
                (setq col (car (nth ci colors)))
                (demo-ui ci colors sz col bi)
                (let ((cc (nth ci colors)))
                  (demo-leds (nth 1 cc) (nth 2 cc) (nth 3 cc)))
                (demo-click (+ 60 (* ci 2))))
              ((or (= kc 115) (= kc 83))
                (setq si (mod (+ si 1) (length sizes)))
                (setq sz (nth si sizes))
                (demo-ui ci colors sz col bi)
                (demo-click (+ 72 (* si 3))))
              ((or (= kc 120) (= kc 88))
                (fill-rect 0 39 512 325 0)
                (demo-click 48))))))
      (delay 8))))

(defun hex-char (n)
  (code-char (+ (if (< n 10) 48 55) n)))

(defun ansi-goto (r c)
  (write-byte 27) (princ "[")
  (princ r) (princ ";") (princ c) (princ "H"))

(defun ansi-cls ()
  (write-byte 27) (princ "[2J")
  (ansi-goto 1 1))

(defun ansi-sgr (n)
  (write-byte 27) (princ "[")
  (princ n) (princ "m"))

(defun font-table ()
  (graphics-mode)
  (fill-screen 0)
  (let ((gx 128) (gy 40) (cs 18) (lc 182) (gc 255) (hc 109))
    (set-text-color gc 0)
    (set-text-size 2)
    (set-cursor 116 8)
    (with-gfx (s) (princ "CP437 Font Map" s))
    (dotimes (c 16)
      (draw-char (+ gx (* c cs) 5) (- gy 10) (hex-char c) hc 0 1))
    (dotimes (r 16)
      (let ((y (+ gy (* r cs))))
        (draw-char (- gx 20) (+ y 5) (hex-char r) hc 0 1)
        (draw-char (- gx 12) (+ y 5) (code-char 95) hc 0 1)
        (dotimes (c 16)
          (draw-char (+ gx (* c cs) 1) (+ y 1) (code-char (+ (* r 16) c)) gc 0 2))))
    (draw-rect (- gx 2) (- gy 2) (+ (* 16 cs) 4) (+ (* 16 cs) 4) 0)
    (set-text-size 1)
    (set-text-color lc 0)
    (set-cursor 104 336)
    (with-gfx (s) (princ "draw-char x y #\\A col bg sz" s))
    (set-cursor 104 348)
    (with-gfx (s) (princ "also: #\\Space #\\' #\\\\ (code-char N)" s))
    (set-cursor 136 360)
    (with-gfx (s) (princ "N = row*16 + col  (0-255)" s))
    (set-cursor 168 372)
    (with-gfx (s) (princ "press any key to exit" s))
    (keyboard-flush)
    (loop (when (keyboard) (text-mode) (return t)))))

(defun font-table-text ()
  (ansi-cls)
  (ansi-sgr 1) (ansi-sgr 37)
  (ansi-goto 1 21)
  (princ "CP437 Font Table")
  (ansi-sgr 0) (ansi-sgr 36)
  (ansi-goto 3 6)
  (dotimes (c 16)
    (princ (hex-char c)) (princ " "))
  (dotimes (r 16)
    (ansi-goto (+ r 4) 2)
    (princ (hex-char r)) (princ "_ ")
    (ansi-sgr 37)
    (dotimes (c 16)
      (let ((ch (+ (* r 16) c)))
        (if (or (< ch 32) (= ch 127))
          (progn (ansi-sgr 2) (princ ". ") (ansi-sgr 0) (ansi-sgr 37))
          (progn (write-byte ch) (princ " ")))))
    (ansi-sgr 36))
  (ansi-sgr 0) (ansi-sgr 2)
  (ansi-goto 21 6)
  (princ "(write-byte N) or (princ #\\A)")
  (ansi-goto 22 4)
  (princ "also: #\\Space #\\' #\\\\  N = row*16 + col")
  (ansi-goto 23 4)
  (princ "0_-1_ and 7F: control chars (use font-table for gfx)")
  (ansi-goto 25 18)
  (princ "press any key to exit")
  (ansi-sgr 0)
  (keyboard-flush)
  (loop (when (keyboard)
    (ansi-goto 26 1) (return t))))

)lisplibrary"
